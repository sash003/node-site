
Node.js предоставляет мощный модуль fs для работы с файлами и каталогами. Он позволяет как синхронно, так и асинхронно читать и записывать данные, управлять директориями, следить за изменениями файлов и строить на этом полноценные серверные приложения. В этой статье мы разберём основные возможности fs, нюансы асинхронности и дадим практические примеры.
<h2>1. Модуль fs: синхронные и асинхронные методы</h2>
В Node.js большинство операций с файлами бывают двух видов:
Асинхронные — не блокируют основной поток выполнения, работают через колбэки или промисы.
Синхронные — блокируют выполнение кода до завершения операции.

Пример подключения:
<pre><code class="language-javascript">
const fs = require('fs');
const path = require('path');
</code></pre>
Синхронное чтение файла
<pre><code class="language-javascript">
const data = fs.readFileSync(path.join(__dirname, 'example.txt'), 'utf-8');
console.log(data);
</code></pre>
⚠️ Минус синхронных методов: пока файл читается, Node.js не обрабатывает другие запросы. Поэтому на сервере обычно используют асинхронные методы.

Асинхронное чтение файла (колбэк)
<pre><code class="language-javascript">
fs.readFile(path.join(__dirname, 'example.txt'), 'utf-8', (err, data) => {
  if (err) {
    console.error('Ошибка чтения файла:', err);
    return;
  }
  console.log(data);
});
</code></pre>
Асинхронное чтение через промисы
<pre><code class="language-javascript">
const fsPromises = fs.promises;
async function readFileAsync() {
  try {
    const data = await fsPromises.readFile(path.join(__dirname, 'example.txt'), 'utf-8');
    console.log(data);
  } catch (err) {
    console.error('Ошибка:', err);
  }
}

readFileAsync();
</code></pre>
<h2>2. Запись файлов</h2>
Node.js позволяет записывать данные в файл как синхронно, так и асинхронно.

Асинхронная запись с колбэком
<pre><code class="language-javascript">
fs.writeFile('output.txt', 'Привет, Node.js!', 'utf-8', (err) => {
  if (err) {
    console.error('Ошибка записи:', err);
  } else {
    console.log('Файл успешно записан!');
  }
});
</code></pre>
Асинхронная запись через промисы
<pre><code class="language-javascript">
async function writeFileAsync() {
  try {
    await fsPromises.writeFile('output.txt', 'Асинхронная запись через промисы', 'utf-8');
    console.log('Файл записан!');
  } catch (err) {
    console.error('Ошибка:', err);
  }
}

writeFileAsync();
  </code></pre>
<h2>3. Проверка существования файлов и директорий</h2>
Часто нужно убедиться, что файл или каталог существует перед чтением или записью.
<pre><code class="language-javascript">
const filePath = path.join(__dirname, 'example.txt');
fs.access(filePath, fs.constants.F_OK, (err) => {
  if (err) {
    console.log('Файл не существует');
  } else {
   console.log('Файл существует');
  }
});
</code></pre>
<h2>4. Работа с директориями</h2>
Создание, чтение и удаление папок также поддерживается через fs.

Создание папки
<pre><code class="language-javascript">
fs.mkdir(path.join(__dirname, 'uploads'), { recursive: true }, (err) => {
  if (err) console.error(err);
  else console.log('Папка создана!');
});
</code></pre>
recursive: true позволяет создавать вложенные директории, даже если родительские не существуют.

Чтение содержимого директории
  <pre><code class="language-javascript">
fs.readdir(__dirname, (err, files) => {
if (err) console.error(err);
else console.log('Файлы в папке:', files);
});
</code></pre>
Удаление папки
<pre><code class="language-javascript">
fs.rmdir(path.join(__dirname, 'uploads'), { recursive: true }, (err) => {
  if (err) console.error(err);
  else console.log('Папка удалена!');
});
</code></pre>
<h2>5. Асинхронность и события</h2>
Асинхронные методы позволяют не блокировать Event Loop. Например, сервер Node.js может обрабатывать HTTP-запросы, пока читается файл.
Для больших файлов можно использовать потоки (Streams):
<pre><code class="language-javascript">
const readStream = fs.createReadStream('bigfile.txt', 'utf-8');

readStream.on('data', chunk => {
  console.log('Прочитано:', chunk.length, 'символов');
});

readStream.on('end', () => {
  console.log('Чтение завершено');
});
</code></pre>
Используя потоки, вы избегаете загрузки всего файла в память.
<h2>6. Практический пример: логирование запросов</h2>
<pre><code class="language-javascript">
const http = require('http');

http.createServer(async (req, res) => {
  const logLine = `${new Date().toISOString()} ${req.method} ${req.url}\n`;

  await fsPromises.appendFile('server.log', logLine);

  res.end('OK');
}).listen(3000, () => console.log('Сервер на порту 3000'));
</code></pre>
Здесь appendFile асинхронно добавляет строки в лог, не блокируя сервер.
<h2>7. Советы по работе с fs</h2>
Используй асинхронные методы, если это серверные приложения. Синхронные только для скриптов или CLI.
Проверяй ошибки всегда, особенно при записи/чтении файлов.
Используй потоки для больших файлов — экономит память.
Старайся хранить пути через path.join, чтобы код был кроссплатформенным.
Node.js и модуль fs дают полный контроль над файловой системой сервера. Зная, как использовать асинхронность, потоки и промисы, можно строить надёжные приложения с логами, загрузкой файлов, генерацией контента и управлением папками без риска блокировки сервера.
  <h2>8. Загрузка файлов: multer + file-type</h2>
В веб-приложениях часто нужно принимать файлы от пользователей — картинки, документы или видео. Для этого в Node.js есть популярный middleware multer.

Установка:
<pre><code class="language-javascript">
npm install multer file-type
</code></pre>
Настройка хранилища
<pre><code class="language-javascript">
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const FileType = require('file-type');

// Настраиваем хранилище для загружаемых файлов через multer
const storage = multer.diskStorage({
   /* Куда сохранять файл
   Функция вызывается для каждого файла
   req  – данные запроса
   file – объект с инфой о файле (имя, тип и т.д.)
   cb   – колбэк, указываем multer куда класть файл */
  destination: (req, file, cb) => {
    // Путь до папки uploads внутри public
    const uploadDir = path.join(__dirname, 'public', 'uploads');

    // Если папки ещё нет — создаём (recursive: true создаст все вложенные, если нужно)
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }

    // Сообщаем multer, куда именно сохранять файл
    cb(null, uploadDir);
  },

  // Как назвать файл при сохранении
  filename: (req, file, cb) => {
    // Делаем уникальное имя: timestamp + оригинальное имя файла
    // Например: 1692718200000-photo.png
    const uniqueName = Date.now() + '-' + file.originalname;

    // Сообщаем multer новое имя
    cb(null, uniqueName);
  }
});

// Собираем сам middleware для загрузки
const upload = multer({
  storage, // используем хранилище, что настроили выше
  limits: {
    fileSize: 10 * 1024 * 1024 // ограничение: 10 МБ на один файл
  }
}).any(); // .any() значит принимать файлы с любыми именами input'ов. Если хочешь сделать жёстче (например, чтобы загружалось максимум 3 файла), можно тут же вместо .any() написать .array('files', 3) — и всё, multer сам обрежет до трёх.
</code></pre>
Проверка формата файла

Даже если пользователь переименует файл (например, virus.jpg.exe), мы можем проверить реальный MIME-тип через file-type:
<pre><code class="language-javascript">
async function checkFileType(filePath) {
  const buffer = await fs.promises.readFile(filePath);
  const type = await FileType.fromBuffer(buffer);
  return type ? type.mime : null;
}
</code></pre>
Обработчик загрузки файлов
<pre><code class="language-javascript">
const express = require('express');
const app = express();

const ALLOWED_MIME = [
  'image/png',
  'image/jpeg',
  'image/gif',
  'video/mp4',
  'audio/mpeg',
  'application/pdf'
];

app.post('/upload', (req, res) => {
  upload(req, res, async (err) => {
    if (err) {
      return res.status(400).json({ success: false, message: 'Ошибка загрузки: ' + err.message });
    }

    const files = req.files || [];

    for (const f of files) {
      const filePath = path.join(f.destination, f.filename);
      const mime = await checkFileType(filePath);

      if (!mime || !ALLOWED_MIME.includes(mime)) {
        fs.unlinkSync(filePath); // удаляем неподходящий файл
        return res.json({ success: false, message: 'Недопустимый формат файла' });
      }
    }

    res.json({ success: true, message: 'Файлы успешно загружены!' });
  });
});

app.listen(3000, () => console.log('Сервер работает на http://localhost:3000'));
</code></pre>
Что мы получили

Загружаем файлы в папку public/uploads.
Ограничили размер до 10 МБ.
Проверяем реальный MIME-тип через file-type, а не только расширение.
Если формат не подходит, файл удаляется.

💡 В реальных проектах к этому добавляют ещё лимит по количеству файлов, автоматическую очистку временных директорий и сохранение информации о файлах в БД.

Таким образом, fs + multer + file-type позволяют безопасно и удобно обрабатывать загрузку файлов в Node.js, не рискуя допустить уязвимости.