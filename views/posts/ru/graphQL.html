<h2>Что такое GraphQL и зачем он появился</h2>
GraphQL — это язык запросов к API и среда для их выполнения. Его придумали в Facebook в 2012 году, когда стало ясно, что классический REST не всегда справляется с задачами в сложных системах. В 2015 году проект открыли, и сегодня GraphQL используют GitHub, Airbnb, Shopify, Pinterest и многие другие компании.

Изначально цель была ускорить мобильное приложение Facebook. Проблема заключалась в том, что при одновременной загрузке данных из разных баз (например, MySQL и Redis) интерфейс начинал сильно тормозить. Особенно это было критично в соцсети, где пользователю одновременно нужны и посты друзей, и лайки, и комментарии. GraphQL стал решением: он позволяет сделать один запрос и получить именно те данные, которые нужны, без лишнего.

<h3>Почему REST не всегда удобен</h3>
REST хорош, но у него есть ряд ограничений:

Избыточные или недостаточные данные. В REST клиент часто получает слишком много полей, либо наоборот слишком мало, и приходится отправлять дополнительные запросы. В GraphQL можно указать только нужные поля и получить всё за один раз.

Много разных эндпоинтов. В REST у каждого ресурса свой путь: /users, /posts, /comments. Это со временем усложняет поддержку и версии API. В GraphQL всегда один универсальный эндпоинт.

Проблема N+1 запросов. В REST для связанных данных приходится каждый раз дёргать новые адреса (например, сначала запросить список пользователей, а потом для каждого — его посты). GraphQL позволяет описать связи прямо в запросе и вернуть все нужные данные сразу.

<h3>Пример из жизни</h3>
Представим задачу: нужно получить список пользователей и последние посты каждого.

В REST это выглядело бы так:
Запросить список пользователей через /users
Для каждого пользователя дополнительно запросить его посты через /posts?user_id=...

В итоге выходит много отдельных запросов.

В GraphQL это делается одним запросом:
<pre><code class="language-javascript">
{
  users {
    id
    name
    posts(limit: 5) {
      title
      createdAt
    }
  }
}
</code></pre>
Результат — аккуратный JSON только с теми полями, которые ты сам указал.

<h3>Вывод</h3>
GraphQL можно назвать следующим шагом после REST. Он избавляет от лишних запросов, ускоряет приложения и делает API более гибким и удобным.

А за счёт чего это работает? Всё дело в самой концепции GraphQL. Он построен вокруг структуры данных в виде графа. В этом графе узлы — это сущности (например, пользователь, пост, комментарий), а рёбра — это связи между ними. Такой подход отражает реальное устройство данных и позволяет гибко описывать отношения.

Отсюда и название — GraphQL. В отличие от REST, где у каждого ресурса отдельный эндпоинт, в GraphQL можно двигаться по связям и сразу забирать только то, что нужно.

Представь, что у нас есть социальная сеть. В графе есть пользователи, у каждого есть посты, у постов — комментарии, а у комментариев — авторы. В REST пришлось бы делать кучу отдельных запросов, а в GraphQL достаточно одного, где эти связи указываются прямо в структуре запроса.

Как же мы получаем доступ к этому графу?
GraphQL всегда начинает с так называемого корневого узла (root). Это точка входа, откуда можно двигаться дальше по связям. В запросе мы говорим: «дай мне пользователя, а вместе с ним его посты и авторов этих постов». Сервер выполняет инструкцию и возвращает ровно ту часть графа, которую мы запросили.

Мы можем взять, например, пользователя 1, и получить данные его подписчика. Давайте напишем фрагмент запроса GraphQL, чтобы показать, как получить к нему доступ:
<pre><code class="language-javascript">
query {
  user(id: "1") {
    followers {
      tweets {
        content
      }
    }
  }
}
</code></pre>
Здесь мы просим GraphQL перейти к графу из корневого узла, который является объектом пользователя с аргументом id: 1, и получить доступ к содержимому твита подписчика.

Для начала неплохо, но давайте обсудим, какие бывают запросы в GraphQL подробнее.

<h2>Типы запросов GraphQL</h2>
Типы запросов в GraphQL сводятся к основным трём:

Query
Mutation
Subscribtion

<h3>Query: запросы в GraphQL</h3>
С ними мы уже немного познакомились в наших примерах раньше.

C помощью Query GraphQL получает необходимые данные с сервера. Тип запроса Query в GraphQL — аналог GET в REST. Запросы — строки, которые отправляются в теле HTTP POST-запроса.

Обратите внимание, все типы запросов в GraphQL отправляются через POST. Но это если мы говорим про обмен по HTTP, и это самый распространённый вариант. Но GraphQL также может работать и через Веб-сокеты, и через gRPC, и поверх других транспортных протоколов.

Примеры Query мы уже видели, но давайте ещё раз для закрепления: получим параметры fname и age всех пользователей:
<pre><code class="language-javascript">
query {
  users {
    fname
    age
  }
}
</code></pre>
В ответ на этот запрос сервер присылает данные в формате JSON. Структура ответа соответствует структуре запроса:
<pre><code class="language-javascript">
data : {
  users [
    {
      "fname": "Joe",
      "age": 23
    },
    {
      "fname": "Betty",
      "age": 29
    }
  ]
}
</code></pre>
В ответе приходит JSON с ключом data  и с ключом errors , если есть какие-то ошибки.

Вот пример ответа, в котором возникла ошибка из-за того, что у Alice в возрасте почему-то текстовое значение:
<pre><code class="language-javascript">
{
  "errors": [
    {
      "message": "Ошибка: Поле 'age' имеет недопустимое значение 'test'.",
      "locations": [
        {
          "line": 5,
          "column": 5
        }
      ],
      "path": ["users", 0, "age"]
    }
  ],
  "data": {
    "users": [
      {
        "fname": "Alice",
        "age": "test"
      },
      {
        "fname": "Bob",
        "age": 32
      }
    ]
  }
}
</code></pre>
<h3>Mutation: мутации в GraphQL</h3>
С помощью мутаций можно добавлять данные в базу. Mutation — это аналог POST и PUT в REST. Вот пример кода:
<pre><code class="language-javascript">
mutation createUser{
  addUser(fname: "Richie", age: 22) {
    id
  }
}
</code></pre>
Здесь создаётся мутация createUser, которая добавляет в БД пользователя с fname Richie и age 22. В ответ на этот запрос сервер присылает JSON с id записи. Ответ выглядит так:
<pre><code class="language-javascript">
data : {
  addUser : "a36e4h"
}
</code></pre>
<h3>Subscription: подписки в GraphQL</h3>
С помощью подписок клиент слушает изменения в БД в режиме реального времени. Под капотом подписки используют Веб-сокеты. Пример кода:
<pre><code class="language-javascript">
subscription listenLikes {
  listenLikes {
    fname
    likes
  }
}
</code></pre>
С помощью этого запроса можно, например, получать список пользователей с именами и количеством лайков каждый раз, когда оно меняется.

Например, когда пользователь с fname Richie получает лайк, ответ будет таким:
<pre><code class="language-javascript">
data: {
  listenLikes: {
    "fname": "Richie",
    "likes": 245
  }
}
</code></pre>
Подобный запрос можно использовать для обновления количества лайков в режиме реального времени в соответствующем интерфейсе, например, в форме с результатами голосования на сайте.
Концепции в запросах GraphQL

Примеры разных запросов мы уже посмотрели, но теперь давайте разберёмся, как называть и организовывать эти элементы, которые используются в GraphQL.

<h3>Концепции, которые мы рассмотрим:</h3>
Поля (Fields)
Аргументы (Arguments)
Псевдонимы (Aliases)
Фрагменты (Fragments)
Переменные (Variables)
Директивы (Directives)
Поля (Fields)

Давайте посмотрим на простой запрос GraphQL:
<pre><code class="language-javascript">
{
  user {
    name
  }
}
</code></pre>
В этом запросе вы видите 2 поля. Поле user возвращает объект, в котором есть другое поле, типа String.

Мы попросили сервер GraphQL вернуть объект пользователя с его именем, тут всё просто, идём дальше.
Аргументы (Arguments)

Вы можете передать аргумент, чтобы указать, на какого пользователя мы хотим ссылаться.

Пример:
<pre><code class="language-javascript">
{
  user(id: "1") {
    name
  }
}
</code></pre>
Мы передаем id пользователя, но мы могли бы также передать аргумент name, предполагая, что у API есть функция для возврата с таким ответом.

У нас также может быть аргумент limit, указывающий, сколько подписчиков мы хотим вернуть в ответе.

Пример:
<pre><code class="language-javascript">
{
  user(id: "1") {
    name
    followers(limit: 50)
  }
}
</code></pre>
<h3>Псевдонимы (Aliases)</h3>
Алиасы (aliases) в GraphQL используются для переименования полей в ответе запроса. Это полезно, когда вы хотите получить данные из нескольких полей с одинаковыми именами, но хотите, чтобы они имели разные имена в ответе. Вот пример запроса GraphQL с использованием алиасов:

Пример:
<pre><code class="language-javascript">
query {
  products {
    name
    description
  }
  users {
    userName: name
    userDescription: description
  }
}
</code></pre>
И пример ответа:
<pre><code class="language-javascript">
{
  "data": {
    "products": [
      {
        "name": "Product A",
        "description": "Description A"
      },
      {
        "name": "Product B",
        "description": "Description B"
      }
    ],
    "users": [
      {
        "userName": "User 1",
        "userDescription": "User Description 1"
      },
      {
        "userName": "User 2",
        "userDescription": "User Description 2"
      }
    ]
  }
}
</code></pre>
Так мы в ответе можем отличить имя и описание продукта от имени и описания пользователя. Помните, мы также делаем и в SQL, когда, например, нужно при джойне двух таблиц в результате различить похожие названия двух столбцов. Обычно эта проблема возникает с колонками id и name.
Фрагменты (Fragments)

Концепция фрагментов часто используется для разделения сложных требований к данным приложения на более мелкие порции, особенно когда вам нужно объединить множество компонентов пользовательского интерфейса с различными фрагментами в одну начальную выборку данных.

Пример:
<pre><code class="language-javascript">
{
  leftComparison: tweet(id: 1) {
    ...comparisonFields
  }
  rightComparison: tweet(id: 2) {
    ...comparisonFields
  }
}

fragment comparisonFields on tweet {
  userName
  userHandle
  date
  body
  repliesCount
  likes
}
</code></pre>
Что происходит в этом запросе?

Мы отправляем два запроса для получения информации о двух разных твитах: твит с id 1 и твит с id 2.

Для каждого запроса мы создаем алиасы: leftComparison и rightComparison.

И мы используем фрагмент comparisonFields, который содержит набор полей, которые мы хотим получить для каждого твита. Фрагменты позволяют нам избежать дублирования кода и переиспользовать один и тот же набор полей в нескольких местах запроса.

Вот какой ответ мы получим:
<pre><code class="language-javascript">
{
  "data": {
    "leftComparison": {
    userName: "foo",
      userHandle: "@foo",
      date: "2019-05-01",
      body: "Life is good",
      repliesCount: 10,
      tweetsCount: 200,
      likes: 500,
    },
    "rightComparison": {
      userName: "boo",
      userHandle: "@boo",
      date: "2018-05-01",
      body: "This blog is awesome",
      repliesCount: 15,
      tweetsCount: 500,
      likes: 700
    }
}
</code></pre>
<h3>Переменные (Variables)</h3>
Переменные GraphQL – это способ динамического указания значения, которое используется в запросе. Как вы видели выше, мы передали наши аргументы внутри строки запроса. Мы будем передавать аргументы с переменной.

В примере мы добавили идентификатор пользователя id в качестве строки внутри запроса:
<pre><code class="language-javascript">
{
  accholder: user(id: "1") {
    fullname: name
  }
}
</code></pre>
Давайте теперь добавим переменную и заменим статическое значение. То же самое можно записать как:
<pre><code class="language-javascript">
query GetAccHolder($id: String) {
  accholder: user(id: $id) {
    fullname: name
  }
}

{
  "id": "1"
}
</code></pre>
Здесь GetAccHolder является именованной функцией. Полезно использовать именованную функцию, когда у вас много запросов в вашем приложении.

Потом мы задекларировали переменную $id с типом String. Ну а дальше уже также, как и в нашем изначальном запросе, но вместо фиксированного ИДшника, мы в запросе отдали переменную $id.
Ну а значения переменных передаются в отдельном блоке. В нашем случае id = 1.

Мы можем указать значение по умолчанию для переменной:
<pre><code class="language-javascript">
query GetAccHolder($id: String = "1") {
  accholder: user(id: $id) {
   fullname: name
  }
}
</code></pre>
Также мы можем сделать переменную, как обязательную, добавив ! к типу данных:
<pre><code class="language-javascript">
query GetAccHolder($id: String!) {
  accholder: user(id: $id) {
    fullname: name
  }
}
</code></pre>
<h3>Директивы (Directives)</h3>
Теперь давайте посмотрим, как можно динамически генерировать структуру запроса, используя директивы.

Директивы помогают динамически изменять структуру и форму наших запросов с помощью переменных.

<b>@include и @skip</b> – две директивы, доступные в GraphQL
Пример директивы:

@include(if: Boolean) — Включить поле, если значение boolean-переменной = true
<pre><code class="language-javascript">
query GetFollowers($id: String) {
  user(id: $id) {
    fullname: name,
    followers: @include(if: $getFollowers) {
      name
      userHandle
      tweets
    }
  }
}

{
  "id": "1",
  "$getFollowers": false
}
</code></pre>
Здесь $getFollowers имеет значение false, следовательно, поле имён подписчиков followers не будет включено в ответ.

@skip(if: Boolean) — Пропустить поле, если значение boolean-переменной = true
<pre><code class="language-javascript">
query GetFollowers($id: String) {
  user(id: $id) {
    fullname: name,
    followers: @skip(if: $getFollowers) {
      name
      userHandle
      tweets
    }
  }
}

{
"id": "1",
"$getFollowers": true
}
</code></pre>
Здесь $getFollowers имеет значение true, следовательно, поле имен подписчиков followers будет пропущено, т. е. исключено из ответа.
Схема GraphQL

Чтобы работать с GraphQL на сервере нужно развернуть схему GraphQL (Schema), где прописывается логика работы GraphQL API, типы и структура данных. Схема состоит из двух взаимосвязанных объектов: TypeDefs и Resolvers.

Выше были описаны основные типы GraphQL. Чтобы сервер мог с ними работать, эти типы необходимо определить. Объект typeDef определяет список типов, которые доступны в проекте. Код выглядит так:
<pre><code class="language-javascript">
const typeDefs= gql`
  type User {
    id: Int
    fname: String
    age: Int
    likes: Int
    posts: [Post]
  }

  type Post {
    id: Int
    user: User
    body: String
  }

  type Query {
    users(id: Int!): User!
    posts(id: Int!): Post!
  }
  type Mutation {
    incrementLike(fname: String!) : [User!]
  }

  type Subscription {
    listenLikes : [User]
  }
`;
</code></pre>
В примере выше определяется тип User, в котором указываются fname, age, likes и другие данные. Для каждого поля определяется тип данных: String или Int. GraphQL поддерживает четыре типа данных: String, Int, Float, Boolean. Если в поле указан восклицательный знак, оно становится обязательным.

Также в примере выше определяются типы Query,Mutation и Subscription.

Первый тип, который содержит внутри себя тип Query, называется users. Он принимает id и возвращает объект с данными соответствующего пользователя. Это обязательное поле. Ещё один тип Query называется posts. Он устроен так же, как users.

Тип Mutation называется incrementLike. Он принимает параметр fname и возвращает список пользователей.

Тип Subscription называется listenLikes. Он возвращает список пользователей.

После определения типов необходимо добавить их логику. Это нужно, чтобы сервер знал, как отвечать на запросы клиента. Эта задача решается с помощью Resolvers.

Resolver или распознаватель — функция, которая возвращает данные для определённого поля. Resolver’ы возвращают данные того типа, который определён в схеме. Распознаватели могут быть асинхронными. С их помощью можно получать данные из REST API, базы данных или другого источника.

Определим Resolver’ы:
<pre><code class="language-javascript">
const resolvers= {
  Query: {
    users(root, args) {return users.filter(user=> user.id=== args.id)[0] },
    posts(root, args) {return posts.filter(post=> post.id=== args.id)[0] }
  },

  User: {
    posts: (user)=> {
return posts.filter(post=> post.userId=== user.id)
    }
  },

  Post: {
    user: (post)=> {
return users.filter(user=> user.id=== post.userId)[0]
    }
  },
  Mutation: {
    incrementLike(parent, args) {
      users.map((user)=> {
if(user.fname=== args.fname) user.likes++return user
      })
      pubsub.publish('LIKES', {listenLikes: users});
return users
    }
  },
  Subscription: {
    listenLikes: {
      subscribe: ()=> pubsub.asyncIterator(['LIKES'])
    }
  }
};
</code></pre>
В примере выше есть шесть функций:

запрос users возвращает объект пользователя, соответствующий переданному id;

запрос posts возвращает объект поста, соответствующий переданному id;

в поле posts User распознаватель принимает данные пользователя и возвращает список его постов;

в поле user Posts функция принимает данные поста и возвращает пользователя, который опубликовал пост;

мутация incrementLike изменяет объект users: увеличивает количество likes для пользователя с соответствующим fname. После этого users публикуются в pubsub с названием LIKES;

подписка listenLikes слушает LIKES и отвечает при обновлении pubsub.

Два слова о pubsub. Этот инструмент представляет собой систему передачи информации в режиме реального времени с использованием вебсокетов. pubsub удобно использовать, так как всё, что касается вебсокетов, вынесено в отдельные абстракции.

<h2>Чем концептуально хорош GraphQL</h2>
<b>Гибкость</b>. GraphQL не накладывает ограничений на типы запросов, что позволяет использовать его как для традиционных CRUD-операций (create, read, update, delete), так и для запросов, которые содержат несколько типов данных.

<b>Определение схемы</b>. GraphQL автоматически создаёт схему для API. А за счёт иерархической организации кода и объектных отношений снижается его сложность.

<b>Оптимизация запросов</b>. GraphQL позволяет клиентам запрашивать только ту информацию, что им нужна. Это уменьшает время ответа от сервера и количество данных, которые нужно передавать по сети.

<b>Контекст</b>. GraphQL учитывает все детали запросов и ответов, что позволяет разработчикам фокусироваться на бизнес-логике. А строго типизированные поля предупреждают разработчиков об ошибках перед выполнением запроса.

<b>Расширяемость</b>. GraphQL позволяет разработчикам расширять схему API и добавлять новые типы данных. При этом есть возможность повторного использования существующего кода и источников данных, чтобы избежать случаев избыточного кода.