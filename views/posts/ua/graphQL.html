<h2>Що таке GraphQL і чому він з’явився</h2>
GraphQL — це мова запитів до API та середовище для їх виконання. Його придумали у Facebook у 2012 році, коли стало зрозуміло, що класичний REST не завжди справляється із завданнями у складних системах. У 2015 році проєкт відкрили, і сьогодні GraphQL використовують GitHub, Airbnb, Shopify, Pinterest та багато інших компаній.

Спочатку метою було прискорити мобільний додаток Facebook. Проблема полягала в тому, що при одночасному завантаженні даних з різних баз (наприклад, MySQL і Redis) інтерфейс починав сильно гальмувати. Особливо це було критично у соцмережі, де користувачу одночасно потрібні й пости друзів, і лайки, і коментарі. GraphQL став рішенням: він дозволяє зробити один запит і отримати саме ті дані, які потрібні, без зайвого.

<h3>Чому REST не завжди зручний</h3>
REST хороший, але має низку обмежень:

Надлишкові або недостатні дані. У REST клієнт часто отримує занадто багато полів або, навпаки, занадто мало, і доводиться відправляти додаткові запити. У GraphQL можна вказати тільки потрібні поля й отримати все за один раз.

Багато різних ендпоінтів. У REST у кожного ресурсу свій шлях: /users, /posts, /comments. Це з часом ускладнює підтримку та версії API. У GraphQL завжди один універсальний ендпоінт.

Проблема N+1 із запитами. У REST для пов’язаних даних доводиться щоразу звертатися за новими адресами (наприклад, спочатку запросити список користувачів, а потім для кожного — його пости). GraphQL дозволяє описати зв’язки прямо в запиті й повернути всі потрібні дані одразу.

<h3>Приклад із життя</h3>
Уявімо задачу: потрібно отримати список користувачів і останні пости кожного.

У REST це виглядало б так:
Запросити список користувачів через /users
Для кожного користувача додатково запросити його пости через /posts?user_id=...

У результаті виходить багато окремих запитів.

У GraphQL це робиться одним запитом:
<pre><code class="language-javascript">
{
  users {
    id
    name
    posts(limit: 5) {
      title
      createdAt
    }
  }
}
</code></pre>
Результат — акуратний JSON тільки з тими полями, які ти сам вказав.

<h3>Висновок</h3>
GraphQL можна назвати наступним кроком після REST. Він позбавляє від зайвих запитів, пришвидшує застосунки та робить API більш гнучким і зручним.

А за рахунок чого це працює? Уся справа в самій концепції GraphQL. Він побудований навколо структури даних у вигляді графа. У цьому графі вузли — це сутності (наприклад, користувач, пост, коментар), а ребра — це зв’язки між ними. Такий підхід відображає реальну будову даних і дозволяє гнучко описувати відносини.

Звідси й назва — GraphQL. На відміну від REST, де у кожного ресурсу окремий ендпоінт, у GraphQL можна рухатися по зв’язках і одразу забирати тільки те, що потрібно.

Уяви, що в нас є соціальна мережа. У графі є користувачі, у кожного є пости, у постів — коментарі, а в коментарів — автори. У REST довелося б робити купу окремих запитів, а в GraphQL достатньо одного, де ці зв’язки вказані прямо в структурі запиту.

Як же ми отримуємо доступ до цього графа?
GraphQL завжди починає з так званого кореневого вузла (root). Це точка входу, звідки можна рухатися далі по зв’язках. У запиті ми говоримо: «дай мені користувача, а разом із ним його пости й авторів цих постів». Сервер виконує інструкцію й повертає рівно ту частину графа, яку ми запросили.

Ми можемо взяти, наприклад, користувача 1 і отримати дані його підписника. Давайте напишемо фрагмент запиту GraphQL, щоб показати, як отримати до нього доступ:
<pre><code class="language-javascript">
query {
  user(id: "1") {
    followers {
      tweets {
        content
      }
    }
  }
}
</code></pre>
Тут ми просимо GraphQL перейти до графа з кореневого вузла, який є об’єктом користувача з аргументом id: 1, і отримати доступ до вмісту твіта підписника.

Для початку непогано, але давайте обговоримо, які бувають запити в GraphQL детальніше.

<h2>Типи запитів GraphQL</h2>
Типи запитів у GraphQL зводяться до основних трьох:

Query
Mutation
Subscription

<h3>Query: запити в GraphQL</h3>
З ними ми вже трохи познайомились у прикладах вище.

За допомогою Query GraphQL отримує потрібні дані з сервера. Тип запиту Query в GraphQL — аналог GET у REST. Запити — це рядки, які відправляються в тілі HTTP POST-запиту.

Зверніть увагу: усі типи запитів у GraphQL відправляються через POST. Але це якщо ми говоримо про обмін по HTTP, і це найпоширеніший варіант. Проте GraphQL також може працювати і через Вебсокети, і через gRPC, і поверх інших транспортних протоколів.

Приклади Query ми вже бачили, але давайте ще раз для закріплення: отримаємо параметри fname і age усіх користувачів:
<pre><code class="language-javascript">
query {
  users {
    fname
    age
  }
}
</code></pre>
У відповідь на цей запит сервер надсилає дані у форматі JSON. Структура відповіді відповідає структурі запиту:
<pre><code class="language-javascript">
data : {
  users [
    {
      "fname": "Joe",
      "age": 23
    },
    {
      "fname": "Betty",
      "age": 29
    }
  ]
}
</code></pre>
У відповіді приходить JSON з ключем data і з ключем errors, якщо є якісь помилки.

Ось приклад відповіді, у якій виникла помилка через те, що у Alice у віці чомусь текстове значення:
<pre><code class="language-javascript">
{
  "errors": [
    {
      "message": "Помилка: Поле 'age' має недопустиме значення 'test'.",
      "locations": [
        {
          "line": 5,
          "column": 5
        }
      ],
      "path": ["users", 0, "age"]
    }
  ],
  "data": {
    "users": [
      {
        "fname": "Alice",
        "age": "test"
      },
      {
        "fname": "Bob",
        "age": 32
      }
    ]
  }
}
</code></pre>
<h3>Mutation: мутації в GraphQL</h3>
За допомогою мутацій можна додавати дані в базу. Mutation — це аналог POST і PUT у REST. Ось приклад коду:
<pre><code class="language-javascript">
mutation createUser{
  addUser(fname: "Richie", age: 22) {
    id
  }
}
</code></pre>
Тут створюється мутація createUser, яка додає в БД користувача з fname Richie і age 22. У відповідь на цей запит сервер надсилає JSON з id запису. Відповідь виглядає так:
<pre><code class="language-javascript">
data : {
  addUser : "a36e4h"
}
</code></pre>
<h3>Subscription: підписки в GraphQL</h3>
За допомогою підписок клієнт слухає зміни в БД у режимі реального часу. Під капотом підписки використовують Вебсокети. Приклад коду:
<pre><code class="language-javascript">
subscription listenLikes {
  listenLikes {
    fname
    likes
  }
}
</code></pre>
За допомогою цього запиту можна, наприклад, отримувати список користувачів з іменами та кількістю лайків щоразу, коли воно змінюється.

Наприклад, коли користувач із fname Richie отримує лайк, відповідь буде такою:
<pre><code class="language-javascript">
data: {
  listenLikes: {
    "fname": "Richie",
    "likes": 245
  }
}
</code></pre>
Подібний запит можна використовувати для оновлення кількості лайків у режимі реального часу у відповідному інтерфейсі, наприклад, у формі з результатами голосування на сайті.

<h3>Концепції в запитах GraphQL</h3>
Приклади різних запитів ми вже подивилися, але тепер давайте розберемося, як називати й організовувати ці елементи, що використовуються в GraphQL.

<h3>Концепції, які ми розглянемо:</h3>
Поля (Fields)
Аргументи (Arguments)
Псевдоніми (Aliases)
Фрагменти (Fragments)
Змінні (Variables)
Директиви (Directives)

<h3>Поля (Fields)</h3>
Давайте подивимося на простий запит GraphQL:
<pre><code class="language-javascript">
{
  user {
    name
  }
}
</code></pre>
У цьому запиті ви бачите 2 поля. Поле user повертає об’єкт, у якому є інше поле, типу String.

Ми попросили сервер GraphQL повернути об’єкт користувача з його ім’ям, тут усе просто, йдемо далі.

<h3>Аргументи (Arguments)</h3>
Ви можете передати аргумент, щоб вказати, на якого користувача ми хочемо посилатися.

Приклад:
<pre><code class="language-javascript">
{
  user(id: "1") {
    name
  }
}
</code></pre>
Ми передаємо id користувача, але ми могли б також передати аргумент name, припускаючи, що в API є функція для повернення з таким результатом.

У нас також може бути аргумент limit, який указує, скільки підписників ми хочемо повернути у відповіді.

Приклад:
<pre><code class="language-javascript">
{
  user(id: "1") {
    name
    followers(limit: 50)
  }
}
</code></pre>

<h3>Псевдоніми (Aliases)</h3>
Аліаси (aliases) у GraphQL використовуються для перейменування полів у відповіді запиту. Це корисно, коли ви хочете отримати дані з кількох полів з однаковими іменами, але щоб вони мали різні імена у відповіді. Ось приклад запиту GraphQL з використанням аліасів:

Приклад:
<pre><code class="language-javascript">
{
  leftComparison: tweet(id: 1) {
    ...comparisonFields
  }
  rightComparison: tweet(id: 2) {
    ...comparisonFields
  }
}

fragment comparisonFields on tweet {
  userName
  userHandle
  date
  body
  repliesCount
  likes
}
</code></pre>
Що відбувається в цьому запиті?

Ми відправляємо два запити для отримання інформації про два різні твіти: твіт з id 1 і твіт з id 2.

Для кожного запиту ми створюємо аліаси: leftComparison і rightComparison.

І ми використовуємо фрагмент comparisonFields, який містить набір полів, які ми хочемо отримати для кожного твіта. Фрагменти дозволяють уникнути дублювання коду та перевикористовувати один і той самий набір полів у кількох місцях запиту.

Ось яку відповідь ми отримаємо:
<pre><code class="language-javascript">
{
  "data": {
    "leftComparison": {
    userName: "foo",
      userHandle: "@foo",
      date: "2019-05-01",
      body: "Life is good",
      repliesCount: 10,
      tweetsCount: 200,
      likes: 500,
    },
    "rightComparison": {
      userName: "boo",
      userHandle: "@boo",
      date: "2018-05-01",
      body: "This blog is awesome",
      repliesCount: 15,
      tweetsCount: 500,
      likes: 700
    }
}
</code></pre>
<h3>Змінні (Variables)</h3>
Змінні GraphQL – це спосіб динамічного задання значення, яке використовується в запиті. Як ви бачили вище, ми передали аргументи всередині рядка запиту. Ми будемо передавати аргументи через змінну.

У прикладі ми додали ідентифікатор користувача id як рядок у запит:
<pre><code class="language-javascript">
{
  accholder: user(id: "1") {
    fullname: name
  }
}
</code></pre>
Додамо змінну та замінимо статичне значення. Те саме можна записати так:
<pre><code class="language-javascript">
query GetAccHolder($id: String) {
  accholder: user(id: $id) {
    fullname: name
  }
}

{
  "id": "1"
}
</code></pre>
Тут GetAccHolder — це іменована функція. Зручно використовувати її, коли у вас багато запитів в одному застосунку.

Ми задекларували змінну $id з типом String. Далі — все як у нашому початковому запиті, але замість фіксованого id ми передаємо змінну $id.
Значення змінних передаються в окремому блоці. У нашому випадку id = 1.

Можна задати значення за замовчуванням:
<pre><code class="language-javascript">
query GetAccHolder($id: String = "1") {
  accholder: user(id: $id) {
   fullname: name
  }
}
</code></pre>
Або зробити змінну обов’язковою, додавши ! до типу:
<pre><code class="language-javascript">
query GetAccHolder($id: String!) {
  accholder: user(id: $id) {
    fullname: name
  }
}
</code></pre>
<h3>Директиви (Directives)</h3>
Подивимося, як можна динамічно змінювати структуру запиту за допомогою директив.

Директиви допомагають динамічно змінювати структуру та форму запитів зі змінними.

<b>@include і @skip</b> – дві директиви, доступні в GraphQL
Приклад:

@include(if: Boolean) — включити поле, якщо змінна = true
<pre><code class="language-javascript">
query GetFollowers($id: String) {
  user(id: $id) {
    fullname: name,
    followers @include(if: $getFollowers) {
      name
      userHandle
      tweets
    }
  }
}

{
  "id": "1",
  "$getFollowers": false
}
</code></pre>
Тут $getFollowers = false, отже поле followers не буде включене у відповідь.

@skip(if: Boolean) — пропустити поле, якщо змінна = true
<pre><code class="language-javascript">
query GetFollowers($id: String) {
  user(id: $id) {
    fullname: name,
    followers @skip(if: $getFollowers) {
      name
      userHandle
      tweets
    }
  }
}

{
"id": "1",
"$getFollowers": true
}
</code></pre>
Тут $getFollowers = true, отже поле followers буде пропущене, тобто виключене з відповіді.
<h3>Схема GraphQL</h3>
Щоб працювати з GraphQL на сервері, потрібно розгорнути схему GraphQL (Schema), де описується логіка роботи API, типи та структура даних. Схема складається з двох об’єктів: TypeDefs і Resolvers.

Вище ми бачили основні типи GraphQL. Їх треба визначити, щоб сервер міг з ними працювати. Об’єкт typeDef визначає список типів у проєкті. Приклад:
<pre><code class="language-javascript">
const typeDefs= gql`
  type User {
    id: Int
    fname: String
    age: Int
    likes: Int
    posts: [Post]
  }

  type Post {
    id: Int
    user: User
    body: String
  }

  type Query {
    users(id: Int!): User!
    posts(id: Int!): Post!
  }
  type Mutation {
    incrementLike(fname: String!) : [User!]
  }

  type Subscription {
    listenLikes : [User]
  }
`;
</code></pre>
У прикладі визначено тип User з полями fname, age, likes тощо. Для кожного поля задається тип: String або Int. GraphQL підтримує 4 типи: String, Int, Float, Boolean. Поле з ! є обов’язковим.

Також визначені типи Query, Mutation і Subscription.

Query users приймає id і повертає користувача. Query posts — аналогічно для постів.

Mutation incrementLike приймає fname і повертає список користувачів.

Subscription listenLikes повертає список користувачів.

Після визначення типів треба додати їх логіку. Це робиться через Resolvers.

Resolver — функція, що повертає дані для поля. Вони можуть бути асинхронними і брати дані з REST API, бази чи іншого джерела.

Приклад:
<pre><code class="language-javascript">
const resolvers= {
  Query: {
    users(root, args) {return users.filter(user=> user.id=== args.id)[0] },
    posts(root, args) {return posts.filter(post=> post.id=== args.id)[0] }
  },

  User: {
    posts: (user)=> {
      return posts.filter(post=> post.userId=== user.id)
    }
  },

  Post: {
    user: (post)=> {
      return users.filter(user=> user.id=== post.userId)[0]
    }
  },
  Mutation: {
    incrementLike(parent, args) {
      users.map((user)=> {
        if(user.fname=== args.fname) user.likes++
        return user
      })
      pubsub.publish('LIKES', {listenLikes: users});
      return users
    }
  },
  Subscription: {
    listenLikes: {
      subscribe: ()=> pubsub.asyncIterator(['LIKES'])
    }
  }
};
</code></pre>
У прикладі є 6 функцій:

запит users повертає користувача з переданим id;

запит posts повертає пост з переданим id;

User.posts повертає список постів користувача;

Post.user повертає автора поста;

мутація incrementLike збільшує likes для користувача з fname, публікує зміни через pubsub;

підписка listenLikes слухає LIKES і відповідає при оновленні.

Pubsub — це система передачі інформації у реальному часі через вебсокети. Вона зручна тим, що все, що стосується вебсокетів, винесено в окремі абстракції.

<h2>Чим концептуально хороший GraphQL</h2>
<b>Гнучкість</b>. GraphQL не обмежує типи запитів. Його можна використовувати як для CRUD-операцій (create, read, update, delete), так і для складних запитів.

<b>Визначення схеми</b>. GraphQL автоматично створює схему API. Ієрархія коду та об’єктні зв’язки зменшують складність.

<b>Оптимізація</b>. GraphQL дозволяє клієнтам запитувати лише потрібні дані. Це зменшує час відповіді та обсяг переданих даних.

<b>Контекст</b>. GraphQL враховує всі деталі запитів і відповідей, що дозволяє зосередитися на бізнес-логіці. Строго типізовані поля попереджають про помилки ще до виконання.

<b>Розширюваність</b>. GraphQL дозволяє розширювати схему API та додавати нові типи даних. Можна повторно використовувати існуючий код і джерела даних, щоб уникати надлишковості.
