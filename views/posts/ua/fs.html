
Node.js надає потужний модуль fs для роботи з файлами та каталогами. Він дозволяє як синхронно, так і асинхронно читати та записувати дані, керувати директоріями, стежити за змінами файлів та будувати на цьому повноцінні серверні програми. У цій статті ми розберемо основні можливості fs, нюанси асинхронності та дамо практичні приклади.
<h2>1. Модуль fs: синхронні та асинхронні методи</h2>
У Node.js більшість операцій із файлами бувають двох видів:
Асинхронні – не блокують основний потік виконання, працюють через колбеки чи проміси.
Синхронні – блокують виконання коду до завершення операції.

Приклад підключення:
<pre><code class="language-javascript">
const fs = require('fs');
const path = require('path');
</code></pre>
Синхронне читання файлу
<pre><code class="language-javascript">
const data = fs.readFileSync(path.join(__dirname, 'example.txt'), 'utf-8');
console.log(data);
</code></pre>
⚠️ Мінус синхронних методів: доки файл читається, Node.js не обробляє інші запити. Тому на сервері зазвичай використовують асинхронні методи.

Асинхронне читання файлу (колбек)
<pre><code class="language-javascript">
fs.readFile(path.join(__dirname, 'example.txt'), 'utf-8', (err, data) => {
  if (err) {
    console.error('Помилка читання файла:', err);
    return;
  }
  console.log(data);
});
</code></pre>
Асинхронне читання через проміси
<pre><code class="language-javascript">
const fsPromises = fs.promises;
async function readFileAsync() {
  try {
    const data = await fsPromises.readFile(path.join(__dirname, 'example.txt'), 'utf-8');
    console.log(data);
  } catch (err) {
    console.error('Ошибка:', err);
  }
}

readFileAsync();
</code></pre>
<h2>2. Записування файлів</h2>
Node.js дозволяє записувати дані у файл як синхронно, і асинхронно.

Асинхронний запис з колбеком
<pre><code class="language-javascript">
fs.writeFile('output.txt', 'Привіт, Node.js!', 'utf-8', (err) => {
  if (err) {
    console.error('Помилка запису:', err);
  } else {
    console.log('Файл успішно записаний!');
  }
});
</code></pre>
Асинхронний запис через проміси
<pre><code class="language-javascript">
async function writeFileAsync() {
  try {
    await fsPromises.writeFile('output.txt', 'Асинхронний запис через проміси', 'utf-8');
    console.log('Файл записаний!');
  } catch (err) {
    console.error('Помилка:', err);
  }
}

writeFileAsync();
</code></pre>
<h2>3. Перевірка існування файлів та директорій</h2>
Часто потрібно переконатися, що файл чи каталог існує перед читанням чи записом.
<pre><code class="language-javascript">
const filePath = path.join(__dirname, 'example.txt');
fs.access(filePath, fs.constants.F_OK, (err) => {
  if (err) {
    console.log('Файл не існує');
  } else {
    console.log('Файл існує');
  }
});
</code></pre>
<h2>4. Робота з директоріями</h2>
Створення, читання та видалення папок також підтримується через fs.

Створення папки
<pre><code class="language-javascript">
fs.mkdir(path.join(__dirname, 'uploads'), { recursive: true }, (err) => {
  if (err) console.error(err);
  else console.log('Папка створена!');
});
</code></pre>
recursive: true дозволяє створювати вкладені директорії, навіть якщо не існують батьківські.

Читання вмісту директорії
<pre><code class="language-javascript">
fs.readdir(__dirname, (err, files) => {
  if (err) console.error(err);
  else console.log('Файли в папці:', files);
});
</code></pre>
Видалення папки
<pre><code class="language-javascript">
fs.rmdir(path.join(__dirname, 'uploads'), { recursive: true }, (err) => {
  if (err) console.error(err);
  else console.log('Папка видалена!');
});
</code></pre>
<h2>5. Асинхронність та події</h2>
Асинхронні методи дають змогу не блокувати Event Loop. Наприклад, сервер Node.js може обробляти запити HTTP, поки читається файл.
Для великих файлів можна використовувати потоки (Streams):
<pre><code class="language-javascript">
const readStream = fs.createReadStream('bigfile.txt', 'utf-8');

readStream.on('data', chunk => {
  console.log('Прочитано:', chunk.length, 'символів');
});

readStream.on('end', () => {
  console.log('Читання завершено');
});
</code></pre>
Використовуючи потоки, ви уникаєте завантаження всього файлу на згадку.
<h2>6. Практичний приклад: логування запитів</h2>
<pre><code class="language-javascript">
const http = require ('http');

http.createServer(async(req, res) => {
  const logLine = `${new Date().toISOString()} ${req.method} ${req.url}\n`;

  await fsPromises.appendFile('server.log', logLine);

  res.end('OK');
}).listen(3000, () => console.log('Сервер на порту 3000'));
</code></pre>
Тут appendFile асинхронно додає рядки в балку, не блокуючи сервер.
<h2>7. Поради щодо роботи з fs</h2>
Використовуйте асинхронні методи, якщо це серверні програми. Синхронні лише для скриптів або CLI.
Перевіряйте помилки завжди, особливо під час запису/читання файлів.
Використовуй потоки для великих файлів – заощаджує пам'ять.
Намагайся зберігати шляхи через path.join, щоб код був кросплатформним.
Node.js та модуль fs дають повний контроль над файловою системою сервера. Знаючи, як використовувати асинхронність, потоки та проміси, можна будувати надійні програми з логами, завантаженням файлів, генерацією контенту та керуванням папками без ризику блокування сервера.
<h2>8. Завантаження файлів: multer + file-type</h2>
У веб-застосунках часто потрібно приймати файли від користувачів - картинки, документи або відео. Для цього у Node.js є популярний middleware multer.
Установка:
<pre><code class="language-javascript">
npm install multer file-type
</code></pre>
Настройка сховища
<pre><code class="language-javascript">
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const FileType = require('file-type');

// Налаштовуємо сховище для файлів, що завантажуються через multer
const storage = multer.diskStorage({
  /* Куди зберігати файл
  Функція викликається для кожного файлу
  req – дані запиту
  file - об'єкт з інформацією про файл (ім'я, тип і т.д.)
  cb – колбек, вказуємо multer куди класти файл */
  destination: (req, file, cb) => {
    // Шлях до папки uploads внутри public
    const uploadDir = path.join(__dirname, 'public', 'uploads');

    // Якщо папки ще немає - створюємо (recursive: true створить всі вкладені, якщо потрібно)
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }

    // Повідомляємо multer, куди саме зберігати файл
    cb(null, uploadDir);
  },

  // Як назвати файл для збереження
  filename: (req, file, cb) => {
    // Робимо унікальне ім'я: timestamp + оригінальне ім'я файлу
    // Наприклад: 1692718200000-photo.png
    const uniqueName = Date.now() + '-' + file.originalname;

    // Повідомляємо multer нове им'я
    cb(null, uniqueName);
  }
});

//Збираємо сам middleware для завантаження
const upload = multer({
storage, // використовуємо сховище, що налаштували вище
limits: {
fileSize: 10*1024*1024 // обмеження: 10 МБ на один файл
}
}).any(); // .any() означає приймати файли з будь-якими іменами input'ів. Якщо хочеш зробити жорсткіше (наприклад, щоб завантажувалося максимум 3 файли), можна відразу замість .any() написати .array('files', 3) — і все, multer сам обріже до трьох.
</code></pre>
Перевірка формату файлу

Навіть якщо користувач перейменує файл (наприклад, virus.jpg.exe), ми можемо перевірити реальний MIME-тип через file-type:
<pre><code class="language-javascript">
async function checkFileType(filePath) {
  const buffer = await fs.promises.readFile(filePath);
  const type = await FileType.fromBuffer(buffer);
  return type ? type.mime : null;
}
</code></pre>
Обробник завантаження файлів
<pre><code class="language-javascript">
const express = require('express');
const app = express();

const ALLOWED_MIME = [
  'image/png',
  'image/jpeg',
  'image/gif',
  'video/mp4',
  'audio/mpeg',
  'application/pdf'
];

app.post('/upload', (req, res) => {
  upload(req, res, async (err) => {
    if (err) {
      return res.status(400).json({ success: false, message: 'Помилка загрузки: ' + err.message });
    }

    const files = req.files || [];

    for (const f of files) {
      const filePath = path.join(f.destination, f.filename);
      const mime = await checkFileType(filePath);

      if (!mime || !ALLOWED_MIME.includes(mime)) {
        fs.unlinkSync(filePath); // видаляємо невідповідний файл
        return res.json({ success: false, message: 'Недопустимий формат файла' });
      }
    }

    res.json({ success: true, message: 'Файлы успішно загружены!' });
  });
});

app.listen(3000, () => console.log('Сервер работает на http://localhost:3000'));
</code></pre>
Що ми отримали

Завантажуємо файли до папки public/uploads.
Обмежили розмір 10 МБ.
Перевіряємо реальний MIME-тип через file-type, а не лише розширення.
Якщо формат не підходить, файл буде видалено.

💡 У реальних проектах до цього додають ще ліміт за кількістю файлів, автоматичне очищення тимчасових директорій та збереження інформації про файли в БД.

Таким чином, fs+multer+file-type дозволяють безпечно та зручно обробляти завантаження файлів у Node.js, не ризикуючи допустити вразливості.